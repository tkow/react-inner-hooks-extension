## What is this

This makes react-hooks callable in a component's child scope by props passing.

## Summary

This makes react-hooks callable in prop as `innerHooks` named.
The `withInnerHooks` create HOC API do this.
In addition, `useStateFactory` API included that makes dynamic mutable object state to add state as the key-value, and it's added when you arbitrary call `usePartialState` hook passed by second tuple element generated by the `useStateFactory` function.

## Usage

```shell
yarn add react-inner-hooks-extension
# or
npm install react-inner-hooks-extension
```

```tsx
// components/NumberInput.tsx
import { ComponentType } from 'react'
import Input from './Input'
import { withInnerHooks } from 'react-inner-hooks-extension'

// components/NumberInput.tsx
type ExtractProps<C> = C extends ComponentType<infer Props> ? Props : any

function NumberInput(props: Omit<ExtractProps<typeof Input>, 'type'>) {
  return <Input type="number" {...props} />
}

export default withInnerHooks(NumberInput)

// App.tsx
import { useCallback, useEffect, useState } from 'react'
import NumberInput from './components/NumberInput'
import Timer from './components/Timer'
import { useStateFactory } from 'react-inner-hooks-extension'

function App() {
  const [state, usePartialState] = useStateFactory({
    num: 0,
  })

  return (
    <div className="App">
        <NumberInput
          innerHooks={() => {
            const [value = 0, setValue] = usePartialState('num')
            return {
              value,
              onChange: (e) => {
                setValue(Number(e.target.value))
              }
            }
          }}
        />
    </div>
  )
}

export default App

```

## API

### withInnerHooks(Component: ComponentType<Props>): ComponentType<Props & {innerHooks?: ()=> Parial<Props> }>

This adds innerHooks prop to passed `Component`. The innerhooks calls in intermediate scope generated as HOC.
The returned object merge the other props from parent and passed to the child as the original `Component` props.

### useStateFactory(initialState: Partial<State> | (() => Partial<State>) [state, usePartialState, setState]

The `useStateFactory` hook return state, getState as first and third element derived from `useState` and `usePartialState` as second element of a tuple. The state and getState of it, and them of useState are completely same api.
The `usePartialState` returns [state, modifierThisState] simular to `useState`. The first difference is that it can't set initialValue from an argument. The reason why is that if you specify it many times the other places, you likely miss where initilize the state named so it must be specified by `useStateFactory` when you need some partial values initialized.
The second difference is you needs to specify state name as key of original state used using string value. Follow this example.

```tsx
import {useEffect} from 'react'
import {withInnerHooks, usePartialState} from 'react-inner-hooks-extension'

const TimerDisplay = withInnerHooks(value => <div>{value}</div>)

function Timer() {
    const [state, usePartialState, setState] = useStateFactory()

    return <TimerDisplay
        innerHooks={
            () => {
                // NOTE: You can avoid undefined by decomposition initialization.
                const [timer = 0, setTimerState] = usePartialState('timer')
                useEffect(()=> {
                    const i = setTimeInterval(()=> setTimerState((state)=> state + 1), 1000)
                    return () => {
                        clearTimeInterval(i)
                    }
                }, [])
                useEffect(()=> {
                    // NOTE: ResetValueEffect
                    if (timer === 10) setState({})
                    // NOTE: You can also write.
                    if (timer === 10) setTimerState(0)
                }, [timer])
                return {
                    value: timer
                }
            }
        }
    />
}
```

# Motivation

Component often needs conditional renderning but hooks must be written before their first starting line even if they don't depend on the condition for [idempotent calling rule of hooks](https://reactjs.org/docs/hooks-rules.html).

Good:

```tsx
const Example = (props) => {
  const options = useOptions();
  const { initialized, data } = useFetchData();
  if (!initialized) return null;
  return <Component {...data} options={options} />;
};
```

Bad:

```tsx
const Example = (props) => {
  const { initialized, data } = useFetchData();
  if (!initialized) return null;
  const options = useOptions();
  return <Component {...data} options={options} />;
};
```

or

```tsx
const Example = (props) => {
  const { initialized, data } = useFetchData();
  if (!initialized) return null;
  return <Component {...data} options={useOptions()} />;
};
```

This is not problem when component is small, but big one is tough to read.

```tsx
const Example = (props) => {
    const options = useOptions()
    const [optionValue, setOptionValue] = useState()
    const {initialized, data} = useFetchData()
    const someValue = ''
    const someChange = () => {}
    if (!initialized) return null
    return (
        <Component>
            <Child>
              <AnnoyedField
                value={someValue}
                onChange={someChange}
                class='test'
                otherProps
              />
              <AnnoyedField
                value={someValue}
                onChange={someChange}
                class='test'
                otherProps
              />
              <AnnoyedField
                value={someValue}
                onChange={someChange}
                class='test'
                otherProps
              />
              <AnnoyedField
                value={someValue}
                onChange={someChange}
                class='test'
                otherProps
              />
              <AnnoyedField
                value={someValue}
                onChange={someChange}
                class='test'
                otherProps
              />
              <AnnoyedField
                value={someValue}
                onChange={someChange}
                class='test'
                otherProps
              />
              <AnnoyedField
                value={someValue}
                onChange={someChange}
                class='test'
                otherProps
              />
              <Select
                value={optionValue}
                onChange={setOptionValue}
                options={options}
                otherProps
              />
              <AnnoyedField
                value={someValue}
                onChange={someChange}
                class='test'
                otherProps
              />
              <AnnoyedField
                value={someValue}
                onChange={someChange}
                class='test'
                otherProps
              />
            <Child/>
        </Component>
    )
}
```

As the farther place it's used from definition, it's more tough to remember the variable name and we are forced to use editor's trick like code jump, bookmark, splited view, etc. Or scroll and switch page many times.

Briefly, innerHooks enables to inject container layer from props using hooks as container component once did. we split one component to presentational component and the container component when we define container in the past. Also in react hooks, it might be better to put container layer using them though it can put them together to one component. However hooks have regulation that they should be defined before rendering, thus you might often be annoyed in the situation as you've seen above. InnerHooks tackeles this problem and realize it can completely encapsulate the business logic to a component in some case.

For example, if you use Redux,

```tsx
    <NumberInput
      innerHooks={() => {
        const num = useSelector(({num}) => { return num})
        const dispatch = useDispatch()
        return {
          value,
          onChange: (e) => {
            dispatch({type: 'mutateNum', payload: num})
          }
        }
      }}
    />
```

you write once, you can use it everywhere just only to move it another place with cut and paste. This is convinent in some case, you obey strictly obey React's hooks rendering rules and declaretive policy.

## Caveat

Inner hooks look opposed to React declarative policy but though also be encapsulated and abstracted by custom hooks. And I think this feature sholud be equipped in React library itself or extend its render function as possible for more effetive about perfomance and avoidance to repeat  to write withInnerHooks hoc any where.
If you use eslint with several react-hooks rules, this library violates some of them. So you may need to ignore them.

## Develop Environment

See example in App.tsx.

```shell
cd ./examples && yarn dev
```

runs example application.

## License

MIT
